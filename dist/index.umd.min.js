!function(e,o){"object"==typeof exports&&"undefined"!=typeof module?o(exports,require("net"),require("ssh2")):"function"==typeof define&&define.amd?define(["exports","net","ssh2"],o):o((e="undefined"!=typeof globalThis?globalThis:e||self).NodeSshTunnel={},e.net,e.ssh2)}(this,(function(e,o,n){"use strict";const r=async e=>{let n=Object.assign({},e);return n.port||n.host||(n=null),new Promise(((e,r)=>{let t=o.createServer(),s=e=>{r(e)};t.on("error",s),process.on("uncaughtException",s),t.listen(n),t.on("listening",(()=>{process.removeListener("uncaughtException",s),e(t)}))}))},t=async e=>new Promise(((o,r)=>{let t=new n.Client;t.on("ready",(()=>{t.removeListener("error",r),o(t)})),t.on("error",(e=>{r(e)})),t.connect(e)})),s=async e=>new Promise((async(o,n)=>{try{console.log("ReCreateSSHConnection");const n=await t(e);o(n)}catch(n){setTimeout((()=>{o(s(e))}),1e3)}}));class c extends Error{code;constructor(e,o){super(e),this.code=o}}class l{connection;sshOptions;servers;constructor(){this.connection=null,this.sshOptions=null,this.servers=null}getConnection(){const{connection:e}=this;if(null===e)throw new Error("Not connected to server");return e}isConnected(){return null!=this.connection}async connect(e){const o=Object.assign({port:22,username:"root"},e),r=new n.Client;return await new Promise(((e,n)=>{r.on("error",n),r.on("ready",(()=>{this.connection=r,r.removeListener("error",n),e(!0)})),r.on("end",(()=>{this.connection===r&&(this.connection=null)})),r.on("close",(()=>{this.connection===r&&(this.connection=null),n(new c("No response from server","ETIMEDOUT"))})),r.connect(o)})),this}async reConnect(){return new Promise((async(e,o)=>{try{console.log("ReCreateSSHConnection");const o=await t(this.sshOptions);e(o)}catch(o){setTimeout((()=>{e(s(this.sshOptions))}),1e3)}}))}async close(){const{connection:e}=this;if(null!==e){try{e.removeAllListeners(),e.end(),e.destroy()}catch(e){console.log(e)}this.connection=null}this.servers?.forEach((e=>{if(e)try{e.close()}catch(e){console.log(e)}})),this.servers=null}async createTunnel(e,o){if(null===this.connection)throw new Error("Not connected to server");if(null!==this.servers)throw new Error("Tunnel already created");this.connection.on("error",(async e=>{t.reconnectOnError?(console.log("ReconnectOnError"),this.connection=await this.reConnect()):(console.log("Error"),console.log(e))}));const n=(Array.isArray(e)?e:[e]).map((e=>Object.assign({dstAddr:"127.0.0.1",srcAddr:"0.0.0.0"},e))),t=Object.assign({autoClose:!1,reconnectOnError:!0},o||{});this.servers=await Promise.all(n.map((async e=>{const o={host:e.srcAddr,port:e.srcPort};let n;const t=(o,n=0)=>{if(null!==this.getConnection()){const n=this.getConnection();try{n.forwardOut(o.remoteAddress??e.srcAddr,o.remotePort??e.srcPort,e.dstAddr,e.dstPort,((e,n)=>{if(e){console.log(e.message),o.on("close",(()=>{})),o.on("error",(()=>{}));try{o.end(),o.destroy()}catch(e){console.log(e)}}else o.on("close",(()=>{n.end()})),o.on("error",(()=>{n.end()})),o.pipe(n).pipe(o)}))}catch(e){o.on("close",(()=>{})),o.on("error",(()=>{}));try{o.end(),o.destroy()}catch(e){console.log(e)}}}else if(n<20)setTimeout((()=>{t(o,n+1)}),500);else try{o.end(),o.destroy()}catch(e){console.log(e)}};try{return n=await r(o),console.log("create tunel success: ",`${e.srcAddr}:${e.srcPort} => ${this.sshOptions?.host}:${e.dstPort}`),n.on("connection",t),n}catch(e){return void console.log(e)}})))}async disconnect(){this.close()}}const i=async(e,o,n)=>{const c=Object.assign({port:22,username:"root"},e),l=(Array.isArray(o)?o:[o]).map((e=>Object.assign({dstAddr:"127.0.0.1",srcAddr:"0.0.0.0"},e))),i=Object.assign({autoClose:!1,reconnectOnError:!0},n||{});let a;const d=e=>{i.reconnectOnError&&(e.on("error",(async()=>{a=void 0,console.log("sshConnection","error"),a=await s(c),d(a),console.log("sshConnection","reconnected")})),e.on("close",(async()=>{})))};try{a=await t(c),d(a)}catch(e){return Promise.reject("用户名或密码错误, 请检查你的配置信息")}const h=await Promise.all(l.map((async o=>{const n={host:o.srcAddr,port:o.srcPort};let t;const s=l=>{i.reconnectOnError&&l.on("error",(async()=>{t=await r(n),s(t)})),l.on("connection",c),l.on("close",(()=>{console.log("close tunel: ",`${o.srcAddr}:${o.srcPort} => ${e.host}:${o.dstPort}`)}))},c=(e,n=0)=>{if(i.autoClose&&((e,o)=>{o.on("close",(()=>{e.getConnections(((o,n)=>{0===n&&e.close()}))}))})(t,e),a)try{a.forwardOut(e.remoteAddress??o.srcAddr,e.remotePort??o.srcPort,o.dstAddr,o.dstPort,((o,n)=>{if(o){console.log(o.message),e.on("close",(()=>{})),e.on("error",(()=>{}));try{e.end(),e.destroy()}catch(e){console.log(e)}}else e.on("close",(()=>{n.end()})),e.on("error",(()=>{n.end()})),e.pipe(n).pipe(e)}))}catch(o){e.on("close",(()=>{})),e.on("error",(()=>{}));try{e.end(),e.destroy()}catch(e){console.log(e)}}else if(n<20)setTimeout((()=>{c(e,n+1)}),500);else{e.on("close",(()=>{})),e.on("error",(()=>{}));try{e.end(),e.destroy()}catch(e){console.log(e)}}};try{return t=await r(n),s(t),console.log("create tunel success: ",`${o.srcAddr}:${o.srcPort} => ${e.host}:${o.dstPort}`),t}catch(e){return void console.log(e)}})));return{servers:h,sshConnection:a,close:()=>{if(h.forEach((e=>{if(e)try{e.close()}catch(e){console.log(e)}})),a)try{a.end(),a.destroy()}catch(e){console.log(e)}}}};e.NodeSSHTunnel=l,e.SSHError=c,e.createTunnel=i,e.createTunnelEx=async(e,o,n)=>{const r=new l;return await r.connect(e),await r.createTunnel(o,n),r},e.default=i,Object.defineProperty(e,"__esModule",{value:!0})}));
